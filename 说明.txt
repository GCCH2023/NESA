1. 注意，在FC系统中，地址是16位的，所以在本程序中，
指针占用2个字节！

2. 函数参数和返回值
(1) 只分析用寄存器 AXY 作为参数和返回值的情况
(2) 参数：如果在一个函数中，对一个变量没有赋值就使用了，那么认为这个变量
是作为参数传递进来的
(3) 返回值：如果在函数内对 AXY 进行了赋值，并且赋值可以到达返回语句，那么
就认为这个寄存器是返回值；由于可能用多个寄存器作为返回值，所以如果有返回值，
就统一使用结构体
struct AXY
{
	char A;
	char X;
	char Y;
};
作为函数的返回值。
翻译时的具体的做法是：如果函数有返回值，那么给它添加一个局部变量
AXY axy;
遍历函数的所有语句，如果是返回语句，则在它前面加上给axy的字段赋值的
语句。

3. 三地址码与字段
C语言
    a.x = 5;
对应三地址码
	t = x * n;  // n 是字段 x 的大小
	a[x] = 5;  // 也就是对象地址偏移 t 个字节后的内存单元
所以，将三地址码翻译为C语句时，要注意数组赋值可能是字段赋值，
如果 a 的类型是结构体对象，那么就是字段赋值。

4. 地址的翻译
如果根据寻址模式，可以确定内存中保存的是地址，
比如 0006 和 0007 两个内存单元共同保存了一个16位地址，
那么应该把这两个内存单元翻译为一个全局变量 g_0006，
它占2个字节，是指针类型（char*或char**)。
但是，NES指令中可能对这个变量赋值，由于NES是8位的CPU，
所以，一次只能赋值一个字节，如果将这个变量设置为指针类型，则
需要进行类型转换，翻译成：
*(char *)&g_0006 = x;
*((char *)&g_0006 + 1) = y;
这样的形式。

5. 全局变量的识别
可以根据 NES 中的寻址模式确定全局变量的地址及其类型，
假设值类型为 ValueType，8位整数类型
(1) 零页寻址 (v = [A])
给定0页地址 A，则将地址为 A 的
    ValueType v
作为全局变量添加到数据库中；
(2) 零页变址寻址（零页 + X 或 零页 + Y）
给定0页地址 A，则将地址为 A 的
	ValueType v[]
作为全局变量添加到数据库中，数组的长度由X或Y的最大值确定；
(3) 绝对寻址
给定绝对地址 A，则将地址为 A 的
    ValueType v
作为全局变量添加到数据库中；
(4) 绝对变址寻址（绝对 + X 或 绝对 + Y）
给定绝对地址 A，则将地址为 A 的
	ValueType v[]
作为全局变量添加到数据库中，数组的长度由X或Y的最大值确定；
(5) 间接寻址 (v = [[A]])
给定间接地址 A，则将地址为 A 的
	ValueType* v
作为全局变量添加到数据库中；
(6) 间接X寻址 (v = [[A + X]])
给定零页间接地址 A，则将地址为 A 的
	ValueType* v[]
作为全局变量添加到数据库中，数组的长度由X的最大值确定；
(7) 间接Y寻址 (v = [A + [Y]])
给定零页间接地址 A，则将地址为 A 的
	ValueType v[]
作为全局变量添加到数据库中，数组的长度由[Y]的最大值确定.

6. 地址与变量
(1) 变量实际上是一段内存，用于存放指定类型的数据
(2) 变量有唯一的首地址（简称地址），可以对应多个地址，比如某个变量的从
地址 100 开始，占用10个字节，那么100就是它的首地址，而 [100, 109] 这10个地址
都属于这个变量。对变量取地址，实际上取得的是它的首地址。
(3) NES 中的地址翻译为C语言
a. 对于零页寻址和绝对寻址，它们都提供了一个地址，目的是操作这个地址的一个字节，
所以，可以翻译为一个char类型的变量。
比如 LDA 06   =>
char g_06;
char A = g_06;
b. 对于变址寻址（零页+XY或绝对+XY），翻译为操作数组元素
比如 LDA [06 + X]  =>
char g_06[];
char X;
char A = g_06[X];
c. 对于间接寻址，翻译为解引用
比如 LDA [[06]]  =>
char* g_06;
char A = *g_06;
d. 对于间接X寻址，翻译为操作数组元素后再解引用
比如 LDA [[06 + X]]  =>
char g_06[];
char X;
char A = *(char*)g_06[X];
e. 间接Y寻址，翻译为解引用后再操作数组元素
比如具体地址的例子，给定地址F0，Y的值为3
地址F0保存的值为20，F1保存的值为30
LDA [3 + [F0]]  = LDA [3 + 3020] = LDA [3023]
=>
char g_3020[];
char* g_F0 = g_3020;
char Y;
char A = g_F0[Y];

7. 变量合并
同一个地址可以用于不同的寻址模式中，应该尽可能的保证对变量的访问不会越界
比如，
Sta [06]
Stx [07]
Stx [Y + [06]]
前面两个零页寻址，06 和 07 将设置为两个 char 变量 g_06, g_07，分别占1个字节，
第3个指令的06是间接Y寻址，06 会认为是 char* 变量，占两个字节
此时，应该将 char g_06 和 char g_07 合并为 char* g_06